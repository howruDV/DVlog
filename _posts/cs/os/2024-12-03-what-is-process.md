---
title:  "OS ㅣ 가상화 01. 프로세스의 개념"
# excerpt: "프로세스의 개념"

categories:
  - CS
  - OS
tags:
  - OS
  - Virtualization
last_modified_at: 2024-12-03

toc: true
toc_label: ""
toc_sticky: true
---



# 📌 (1) 프로세스의 개념
## [프로세스란]
프로세스란 프로그램이 메모리에 로드돼 실행 중인 프로그램 인스턴스다.

> 💡 프로그램 vs 프로세스 vs 스레드
> - 프로그램 : 디스크에 저장된 정적인 상태의 명령어와 데이터 집합
> - 프로세스 : 동적 실행 단위로, 실행 중인 프로그램 인스턴스
> - 스레드 : 프로세스 내에서 실행되는 작업의 가장 작은 실행 단위

## [프로세스의 데이터 영역]
![Pasted image 20241203204922](https://github.com/user-attachments/assets/c96c1ea8-211e-49a2-90e8-4d382c50478d)
- 코드 영역
	- 프로그램 코드가 명령어로 변환돼 저장되는 공간
	- 컴파일 타임에 결정되는 Read-Only Memory

- 데이터 영역
	- 프로그램이 사용하는 정적인 데이터를 저장하는 공간 (전역 변수, static 변수)
	- Read-Write Memory

- 힙 영역
	- 런타임에 동적으로 할당하는 메모리 공간
	- 메모리 사용 시 사용자가 직접 할당-해제하며 관리 필요

- 스택 영역
	- **데이터 저장** : 함수에서 사용하는 데이터를 임시로 저장하는 공간 (지역변수, 매개변수, 리턴값)
	- **주소 저장** : 함수의 수행을 마치고 복귀할 주소를 저장하는 공간
	- **LIFO (Last In First Out)** : 함수 호출 시 쌓이고 리턴 시 해제됨

## [CPU 가상화]
- 시분할 기법(time sharing)
	- 적은 CPU로 동시에 여러 개의 프로세스를 실행하기 위해
	- 각 프로세스에 짧은 시간 동안 CPU를 할당한 후, 빠르게 다른 프로세스로 전환하여
	- 마치 동시에 실행되는 것처럼 보이게 함

- CPU 가상화 구현
	1. 저수준 도구 : mechanism
		- 기능을 구현하는 방법이나 규칙
		- "어떻게 구현"하는지
	
	2. 고차원적 지능 : policy
		- 운영체제에서 결정을 내리기 위한 알고리즘
		- "무엇을 선택"하는지

>💡 Mechanism과 Policy의 분리
> 
>운영체제의 설계 패러다임은 고수준 정책을 저수준 기법과 분리하는 것임
>- Modularity 설계 원칙
>- Policy를 변경할 때 Mechanism의 변경을 고민하지 않아도 됨

# 📌 (2) 프로세스의 하드웨어 상태
프로그램이 실행되는 동안 하드웨어 상태를 읽거나 갱신할 수 있다.

- 메모리
	- 프로세스의 하드웨어 상태 중 가장 중요한 요소
	- 명령어, 데이터가 메모리에 저장됨

- 레지스터
	- 명령어들은 레지스터를 읽거나 갱신함
	- 프로그램 실행을 위한 레지스터
		- Program Counter (PC, Instruction Pointer (IC)) : 프로그램의 실행 중인 명령어 가리킴
		- Stack Pointer (SP) : 함수의 변수와 리턴주소 저장
		- Frame Pointer (FP)

- 영구 저장장치

# 📌 (3) 프로세스 생성
프로세스 생성 위한 OS 작업단계

1. Load (Code & Data)
	- 프로그램의 코드와 데이터를 프로세스 메모리 영역으로 올린다
	- 메모리 가상화
		- 초기 운영체제는 모든 코드와 데이터를 메모리에 탑재했다
		- 현대적인 운영체제는 필요한 부분만 메모리에 탑재한다
		- 연관 개념 : paging, swapping

2. Stack 메모리 영역 할당

3. Heap 메모리 영역 할당

4. 입출력 초기화

5. 실행

# 📌 (4) 프로세스 상태
프로세스의 상태는 크게 3가지가 있다.
프로세스의 상태는 운영체제의 스케쥴링 결정에 따라 전환된다.

- Running
	- 프로세서가 프로세스를 실행 중인 상태

- Ready
	- 실행할 준비가 되어 실행을 기다리고 있는 상태

- Wait
	- 프로세스의 수행이 중단된 상태

# 📌 (5) 프로세스 API
## [fork() 시스템 콜]
fork()는 프로세스 생성에 사용되는 시스템 콜로, 부모 프로세스의 복사본인 자식 프로세스를 생성해 실행한다.
```c++
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        // 자식 프로세스
        printf("Child process\n");
        execlp("/bin/ls", "ls", NULL);
    } else if (pid > 0) {
        // 부모 프로세스
        wait(NULL);
        printf("Parent process\n");
    } else {
        // fork 실패
        perror("fork failed");
    }
    return 0;
}

```

fork() 리턴값
- 부모 프로세스 : 생성된 자식 프로세스의 PID 반환
- 자식 프로세스 : 0 반환

자식 프로세스
- 부모 프로세스의 진행 부분부터 시작
- 프로세스는 독립된 메모리 공간을 가짐 : 자신의 주소 공간, 레지스터, Program Counter를 가짐

## [wait() 시스템 콜]
부모 프로세스가 자식 프로세스의 종료를 대기한다.

## [exec() 시스템 콜]
자기 자신이 아닌 다른 프로그램을 실행하는 경우 사용한다.
이 때 다른 프로세스를 만드는 것이 아니라, 현재 프로세스를 덮어씌운다.

- 코드 세그먼트, 데이터 세그먼트 영역을 덮어씌움
- 스택 세그먼트, 힙 세그먼트는 초기화됨

## [fork와 exec]
UNIX의 쉘을 구현하기 위해서는 fork와 exec의 분리가 필요하다.
fork를 호출한 후, 환경 설정이나 준비와 같은 다양한 코드를 exec를 호출하기 전에 실행한다.

- 예시
    - 출력 재지정 `wc p3.c > newfile.txt`
    - UNIX 파이프 `grep foo file | wc -1`